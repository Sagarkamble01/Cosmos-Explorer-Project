<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmos Explorer - Interactive 3D Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        
        #hud-panel {
            position: absolute; bottom: 40px; right: 40px;
            width: 320px; background: rgba(10, 20, 40, 0.85);
            border: 1px solid #4facfe; border-radius: 12px;
            padding: 20px; color: #fff;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
            transform: translateX(120%); transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }
        #hud-panel.active { transform: translateX(0); }
        
        h1 { margin: 0 0 10px 0; font-size: 24px; color: #4facfe; text-transform: uppercase; letter-spacing: 2px; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; color: #ccc; }
        .data-val { color: #fff; font-weight: bold; }
        #planet-desc { margin-top: 15px; font-size: 13px; line-height: 1.5; color: #aab; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }

        /* Camera Feed */
        #cam-preview {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border: 2px solid #333; border-radius: 8px;
            overflow: hidden; transform: scaleX(-1); /* Mirror */
            opacity: 0.7; transition: opacity 0.3s;
        }
        #cam-preview:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* Instructions */
        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255,255,255,0.6); font-size: 12px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
        }
        .gesture-icon { display: inline-block; width: 10px; height: 10px; background: #4facfe; border-radius: 50%; margin-right: 5px; }

        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #4facfe; font-size: 20px; z-index: 999;
        }
    </style>
</head>
<body>

    <div id="loader">Initializing Universe...</div>

    <div id="ui-layer">
        <div id="instructions">
            <h3>Controls</h3>
            <p> Mouse: Drag to Rotate, Scroll to Zoom, Click to Select</p>
            <p> Gestures (Camera):</p>
            <ul style="padding-left: 20px; margin: 5px 0;">
                <li>Pinch: Zoom In</li>
                <li>Open Hand: Zoom Out</li>
                <li>Swipe Left/Right: Navigate Planets</li>
                <li>Fist + Move: Rotate Universe</li>
            </ul>
        </div>

        <div id="hud-panel">
            <h1 id="p-name">Planet</h1>
            <div class="data-row"><span>Distance</span><span id="p-dist" class="data-val">0 AU</span></div>
            <div class="data-row"><span>Radius</span><span id="p-rad" class="data-val">0 km</span></div>
            <div class="data-row"><span>Speed</span><span id="p-speed" class="data-val">0 km/s</span></div>
            <div class="data-row"><span>Atmosphere</span><span id="p-atm" class="data-val">-</span></div>
            <p id="p-desc">Description...</p>
        </div>
    </div>

    <div id="cam-preview">
        <video id="input_video"></video>
    </div>

    <!-- Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
    <!-- MediaPipe (Global Scope) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- CONFIGURATION ---
        const PLANET_DATA = [
            { name: "Mercury", radius: 2.4, dist: 40, speed: 0.015, color: 0xA5A5A5, atm: "None", desc: "The smallest planet in the Solar System and the closest to the Sun." },
            { name: "Venus", radius: 6.0, dist: 60, speed: 0.012, color: 0xE3BB76, atm: "CO2", desc: "Second planet from the Sun. It has a thick, toxic atmosphere." },
            { name: "Earth", radius: 6.3, dist: 85, speed: 0.010, color: 0x2233FF, atm: "N2/O2", desc: "Our home planet. The only known planet to harbor life." },
            { name: "Mars", radius: 3.3, dist: 110, speed: 0.008, color: 0xFF4500, atm: "CO2", desc: "The Red Planet. Dusty, cold, desert world with a very thin atmosphere." },
            { name: "Jupiter", radius: 14.0, dist: 160, speed: 0.005, color: 0xD9A066, atm: "H2/He", desc: "The largest planet. A gas giant with a Great Red Spot." },
            { name: "Saturn", radius: 11.5, dist: 210, speed: 0.004, color: 0xF4D03F, atm: "H2/He", desc: "Adorned with a dazzling, complex system of icy rings." },
            { name: "Uranus", radius: 8.0, dist: 250, speed: 0.003, color: 0x4FD0E7, atm: "H2/He/CH4", desc: "An ice giant. It rotates at a nearly 90-degree angle." },
            { name: "Neptune", radius: 7.8, dist: 290, speed: 0.002, color: 0x2E86C1, atm: "H2/He/CH4", desc: "The most distant major planet. Dark, cold, and whipped by supersonic winds." }
        ];

        // --- APP STATE ---
        const state = {
            currentPlanetIndex: -1,
            isAutoRotating: true,
            lastGestureTime: 0,
            gestureCooldown: 1000, // ms
            handX: 0,
            handY: 0,
            isFist: false
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 100, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // Post-Processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 800;
        controls.minDistance = 20;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft white light
        scene.add(ambientLight);

        const sunLight = new THREE.PointLight(0xffffff, 2, 600);
        scene.add(sunLight);

        // --- UNIVERSE GENERATION ---
        
        // 1. Stars Background
        const starGeo = new THREE.BufferGeometry();
        const starCount = 8000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 1500;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // 2. The Sun
        const sunGeo = new THREE.SphereGeometry(15, 64, 64);
        
        // Procedural texture to ensure visibility
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffaa00';
        ctx.fillRect(0, 0, 128, 128);
        for(let i=0; i<40; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#ffdd00' : '#ff5500';
            ctx.beginPath();
            ctx.arc(Math.random()*128, Math.random()*128, Math.random()*20+5, 0, Math.PI*2);
            ctx.fill();
        }
        const sunTexture = new THREE.CanvasTexture(canvas);
        const sunMat = new THREE.MeshBasicMaterial({ map: sunTexture });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        // Add a glow sprite
        const spriteMat = new THREE.SpriteMaterial({ 
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/glow.png'), 
            color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending 
        });
        const sunGlow = new THREE.Sprite(spriteMat);
        sunGlow.scale.set(80, 80, 1);
        sun.add(sunGlow);
        scene.add(sun);

        // 3. Planets
        const planetObjects = []; // Stores { mesh, orbitGroup, data, angle }
        
        PLANET_DATA.forEach(data => {
            // Orbit Group (Pivot)
            const orbitGroup = new THREE.Group();
            scene.add(orbitGroup);

            // Orbit Path (Visual Line)
            const pathGeo = new THREE.RingGeometry(data.dist - 0.2, data.dist + 0.2, 128);
            const pathMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.05 });
            const pathMesh = new THREE.Mesh(pathGeo, pathMat);
            pathMesh.rotation.x = Math.PI / 2;
            scene.add(pathMesh);

            // Planet Mesh
            const geometry = new THREE.SphereGeometry(data.radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: data.color, 
                roughness: 0.7,
                metalness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = data.dist;
            
            // Saturn Rings Special Case
            if(data.name === "Saturn") {
                const ringGeo = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.2, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xaa8866, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const rings = new THREE.Mesh(ringGeo, ringMat);
                rings.rotation.x = Math.PI / 2.2;
                mesh.add(rings);
            }

            orbitGroup.add(mesh);
            
            // Store reference
            planetObjects.push({
                mesh: mesh,
                group: orbitGroup,
                data: data,
                angle: Math.random() * Math.PI * 2,
                speed: data.speed
            });
        });

        // --- INTERACTION LOGIC ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectPlanet(index) {
            if (index < 0 || index >= planetObjects.length) return;
            
            state.currentPlanetIndex = index;
            const target = planetObjects[index];
            
            // Update HUD
            document.getElementById('p-name').innerText = target.data.name;
            document.getElementById('p-dist').innerText = target.data.dist + " M km";
            document.getElementById('p-rad').innerText = target.data.radius * 1000 + " km";
            document.getElementById('p-speed').innerText = (target.data.speed * 1000).toFixed(1) + " km/s";
            document.getElementById('p-atm').innerText = target.data.atm;
            document.getElementById('p-desc').innerText = target.data.desc;
            document.getElementById('hud-panel').classList.add('active');

            // Cinematic Camera Move
            // Calculate target position: offset from planet
            const offset = new THREE.Vector3(target.data.radius * 4, target.data.radius * 2, target.data.radius * 4);
            
            // We need to animate the controls target to the planet
            // And the camera position relative to the planet
            
            // Stop auto rotation temporarily if desired, or let it flow
            // For cinematic feel, we lock onto the planet
            
            gsap.to(controls.target, {
                duration: 1.5,
                x: target.mesh.getWorldPosition(new THREE.Vector3()).x,
                y: target.mesh.getWorldPosition(new THREE.Vector3()).y,
                z: target.mesh.getWorldPosition(new THREE.Vector3()).z,
                onUpdate: () => controls.update()
            });

            // Move camera close
            // Note: Since planet is moving, this is a one-time move. 
            // In a full engine, we'd parent the camera or update every frame. 
            // Here we just zoom in to the current location.
            const worldPos = target.mesh.getWorldPosition(new THREE.Vector3());
            gsap.to(camera.position, {
                duration: 1.5,
                x: worldPos.x + 20,
                y: worldPos.y + 10,
                z: worldPos.z + 20,
                ease: "power2.inOut"
            });
        }

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetObjects.map(p => p.mesh));
            
            if(intersects.length > 0) {
                const selectedMesh = intersects[0].object;
                const index = planetObjects.findIndex(p => p.mesh === selectedMesh);
                selectPlanet(index);
            } else {
                // Deselect
                document.getElementById('hud-panel').classList.remove('active');
                state.currentPlanetIndex = -1;
            }
        });

        // --- GESTURE HANDLING (MediaPipe) ---
        const videoElement = document.getElementById('input_video');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

            const landmarks = results.multiHandLandmarks[0]; // Use first hand
            
            // 1. Calculate Pinch (Thumb Tip to Index Tip)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // 2. Calculate Hand Centroid (for Swipe/Rotate)
            const wrist = landmarks[0];
            const middleFinger = landmarks[12];
            const handX = wrist.x;
            const handY = wrist.y;

            // 3. Detect Fist (All fingers closed)
            // Simple heuristic: Tips below PIP joints (y is inverted in some coords, but MP is normalized 0-1 top-left)
            // Actually, let's check distance of tips to wrist vs PIP to wrist
            const isFist = (
                landmarks[8].y > landmarks[6].y && 
                landmarks[12].y > landmarks[10].y && 
                landmarks[16].y > landmarks[14].y && 
                landmarks[20].y > landmarks[18].y
            );
            state.isFist = isFist;

            // --- ACTIONS ---
            const now = Date.now();

            // ZOOM (Pinch vs Open)
            if (distance < 0.05) {
                // Pinch -> Zoom In
                camera.position.addScaledVector(camera.getWorldDirection(new THREE.Vector3()), 2);
            } else if (distance > 0.15 && !isFist) {
                // Wide Open -> Zoom Out
                camera.position.addScaledVector(camera.getWorldDirection(new THREE.Vector3()), -2);
            }

            // SWIPE (Navigation)
            // Check horizontal velocity
            if (now - state.lastGestureTime > state.gestureCooldown) {
                const dx = handX - state.handX;
                if (Math.abs(dx) > 0.15) { // Significant movement
                    if (dx > 0) {
                        // Swipe Right -> Previous Planet
                        let next = state.currentPlanetIndex - 1;
                        if (next < 0) next = planetObjects.length - 1;
                        selectPlanet(next);
                    } else {
                        // Swipe Left -> Next Planet
                        let next = state.currentPlanetIndex + 1;
                        if (next >= planetObjects.length) next = 0;
                        selectPlanet(next);
                    }
                    state.lastGestureTime = now;
                }
            }

            // ROTATE (Fist + Drag)
            if (isFist) {
                const dx = handX - state.handX;
                const dy = handY - state.handY;
                // Rotate scene based on movement
                scene.rotation.y += dx * 5;
                scene.rotation.x += dy * 2;
            }

            // Update state
            state.handX = handX;
            state.handY = handY;
        }

        // Initialize MediaPipe Hands
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotate Planets
            planetObjects.forEach(p => {
                p.angle += p.speed * 0.1; // Orbit speed
                p.group.rotation.y = p.angle;
                
                // Self rotation
                p.mesh.rotation.y += delta * 0.1;
            });

            // Rotate Sun
            sun.rotation.y += delta * 0.02;

            // Update Controls
            controls.update();

            // If tracking a planet, keep looking at it
            if (state.currentPlanetIndex !== -1) {
                const target = planetObjects[state.currentPlanetIndex];
                const worldPos = target.mesh.getWorldPosition(new THREE.Vector3());
                controls.target.lerp(worldPos, 0.1);
            }

            // Render with Bloom
            composer.render();
        }

        animate();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard Fallback
        window.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowRight') {
                let next = state.currentPlanetIndex + 1;
                if (next >= planetObjects.length) next = 0;
                selectPlanet(next);
            }
            if(e.key === 'ArrowLeft') {
                let next = state.currentPlanetIndex - 1;
                if (next < 0) next = planetObjects.length - 1;
                selectPlanet(next);
            }
            if(e.key === 'Escape') {
                state.currentPlanetIndex = -1;
                document.getElementById('hud-panel').classList.remove('active');
                gsap.to(camera.position, { x: 0, y: 100, z: 300, duration: 2 });
                gsap.to(controls.target, { x: 0, y: 0, z: 0, duration: 2 });
            }
        });
    </script>
</body>
</html>